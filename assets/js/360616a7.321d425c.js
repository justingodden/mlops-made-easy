"use strict";(self.webpackChunkmlops_made_easy=self.webpackChunkmlops_made_easy||[]).push([[4257],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=s(n),m=o,h=c["".concat(p,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:o,l[1]=i;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1141:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:3},l="Up and Running",i={unversionedId:"kubernetes/up-and-running",id:"kubernetes/up-and-running",title:"Up and Running",description:"Time to get hands-on with Kubernetes.",source:"@site/docs/02-kubernetes/03-up-and-running.md",sourceDirName:"02-kubernetes",slug:"/kubernetes/up-and-running",permalink:"/kubernetes/up-and-running",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Kubernetes Overview",permalink:"/kubernetes/kubernetes-overview"},next:{title:"Helm",permalink:"/kubernetes/helm"}},p={},s=[{value:"Installation",id:"installation",level:2},{value:"Install <code>kubectl</code>",id:"install-kubectl",level:3},{value:"Install <code>kind</code>",id:"install-kind",level:3},{value:"<code>kind create cluster</code>",id:"kind-create-cluster",level:2},{value:"Hello, Kubernetes!",id:"hello-kubernetes",level:2},{value:"Most basic version",id:"most-basic-version",level:2},{value:"Pod",id:"pod",level:3},{value:"Port Forward",id:"port-forward",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"More Robust Version",id:"more-robust-version",level:2},{value:"Namespace",id:"namespace",level:3},{value:"Deployment",id:"deployment",level:3},{value:"Service",id:"service",level:3},{value:"Ingress",id:"ingress",level:3},{value:"Cleanup",id:"cleanup-1",level:2},{value:"<code>kind delete cluster</code>",id:"kind-delete-cluster",level:3}],d={toc:s},c="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"up-and-running"},"Up and Running"),(0,o.kt)("p",null,"Time to get hands-on with Kubernetes."),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"We'll need to install two tools to create a cluster and to interact with that cluster, ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"kind"),"."),(0,o.kt)("h3",{id:"install-kubectl"},"Install ",(0,o.kt)("inlineCode",{parentName:"h3"},"kubectl")),(0,o.kt)("p",null,"First, let's install the Kubernetes command-line tool, ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/kubectl/"},(0,o.kt)("inlineCode",{parentName:"a"},"kubectl"))," which allows you to run commands against Kubernetes clusters. You can use kubectl to deploy applications, inspect and manage cluster resources, and view logs."),(0,o.kt)("p",null,"kubectl is installable on a variety of Linux platforms, macOS and Windows. Find your preferred operating system below."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/tasks/tools/install-kubectl-linux"},"Install kubectl on Linux")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/tasks/tools/install-kubectl-macos"},"Install kubectl on macOS")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/tasks/tools/install-kubectl-windows"},"Install kubectl on Windows"))),(0,o.kt)("p",null,"As mentioned in the installation guides, you can issue the command below to ensure that it installed successfully."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl version --client\n")),(0,o.kt)("admonition",{title:"Note",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The above command will generate a warning:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre"},"WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.\n")),(0,o.kt)("p",{parentName:"admonition"},"You can ignore this warning. You are only checking the version of kubectl that you have installed.")),(0,o.kt)("h3",{id:"install-kind"},"Install ",(0,o.kt)("inlineCode",{parentName:"h3"},"kind")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"kind")," is a tool for running local Kubernetes clusters inside Docker containers (KinD - Kubernetes in Docker). It's only made for local development, not production, but is immensely useful. You can install ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," for your appropriate OS using their ",(0,o.kt)("a",{parentName:"p",href:"https://kind.sigs.k8s.io/docs/user/quick-start/"},"installation guide"),"."),(0,o.kt)("h2",{id:"kind-create-cluster"},(0,o.kt)("inlineCode",{parentName:"h2"},"kind create cluster")),(0,o.kt)("p",null,"All you need is the command ",(0,o.kt)("inlineCode",{parentName:"p"},"kind create cluster")," and that will spin up a local Kubernetes cluster. But before you do, you can also create the cluster from a config yaml file with extra options. Create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"kind-config.yaml")," and paste in the code below. This adds annotations to the cluster node for it to work with an ",(0,o.kt)("inlineCode",{parentName:"p"},"Ingress Controller"),". We will go into much greater details about the Kubernetes ",(0,o.kt)("inlineCode",{parentName:"p"},"Ingress")," object later, but essentially it's a way of exposing your services to the outside the cluster, and doing intelligent path-based routing for HTTP traffic (e.g. example.com/a routes to application A and example.com/b routes to application B). This need to be set up during cluster creation and will come in handy later."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"extraPortMappings")," allow the local host to make requests to the Ingress controller over ports 80/443, so you can test an application routing with ",(0,o.kt)("inlineCode",{parentName:"p"},"http://localhost/app-a")," for example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="kind-config.yaml"',title:'"kind-config.yaml"'},'kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n  - role: control-plane\n    kubeadmConfigPatches:\n      - |\n        kind: InitConfiguration\n        nodeRegistration:\n          kubeletExtraArgs:\n            node-labels: "ingress-ready=true"\n    extraPortMappings:\n      - containerPort: 80\n        hostPort: 80\n        protocol: TCP\n      - containerPort: 443\n        hostPort: 443\n        protocol: TCP\n')),(0,o.kt)("p",null,"There are many other options you can add, such as giving the cluster a name with the ",(0,o.kt)("inlineCode",{parentName:"p"},"--name")," flag, but by default the cluster is just named ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," and that's fine to leave it like that. You can also set the number of master and worker nodes to match your production environment, but we wont mess with any of those settings."),(0,o.kt)("p",null,"Create the cluster and pass it the config file with the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kind create cluster --config=kind-config.yaml\n")),(0,o.kt)("h2",{id:"hello-kubernetes"},"Hello, Kubernetes!"),(0,o.kt)("p",null,"Okay, we have our K8s cluster with ",(0,o.kt)("inlineCode",{parentName:"p"},"kind"),", and we have ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl")," to interactive with it. Let's get our first application up and running. We'll keep this section ",(0,o.kt)("em",{parentName:"p"},"relatively")," simple, as we'll be using Kubernetes throughout course, so there will be plenty of opportunity to learn more in depth."),(0,o.kt)("p",null,"We can re-use the ",(0,o.kt)("inlineCode",{parentName:"p"},"streamlit")," application from the Docker ",(0,o.kt)("a",{parentName:"p",href:"../containers/docker-custom-containers#the-app"},"section"),". If you followed along, the container image address would be ",(0,o.kt)("inlineCode",{parentName:"p"},"<your-dockerhub-username>/mystreamlitapp:0.1.0"),", but if not then you can use our pre-made one with ",(0,o.kt)("inlineCode",{parentName:"p"},"justingodden/mystreamlitapp:0.1.0")),(0,o.kt)("h2",{id:"most-basic-version"},"Most basic version"),(0,o.kt)("h3",{id:"pod"},"Pod"),(0,o.kt)("p",null,"We can start with K8s' lowest abstraction, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Pod"),". This can contain one or more containers. In the manifest below, we have created a ",(0,o.kt)("inlineCode",{parentName:"p"},"kind: Pod"),", named it ",(0,o.kt)("inlineCode",{parentName:"p"},"my-pod"),", given it the specification to have one container named ",(0,o.kt)("inlineCode",{parentName:"p"},"my-container"),", told it to use the image ",(0,o.kt)("inlineCode",{parentName:"p"},"justingodden/mystreamlitapp:0.1.0")," (or replace this with your Dockerhub username), and finally said to expose the container's port 8501 on the pod's port 8501."),(0,o.kt)("p",null,"Create the yaml file below, named ",(0,o.kt)("inlineCode",{parentName:"p"},"pod.yaml")," in your working directory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="pod.yaml"',title:'"pod.yaml"'},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n    - name: my-container\n      image: justingodden/mystreamlitapp:0.1.0 # replace with your username if you'd like\n      ports:\n        - containerPort: 8501\n")),(0,o.kt)("p",null,"To create the resource in our cluster use the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f pod.yaml\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"-f")," flag tells ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl")," to use a file as a manifest for the object that you'd like to create."),(0,o.kt)("p",null,"We can test if this worked using the command below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods\n")),(0,o.kt)("p",null,"Hopefully if it went to plan, you should see an output like below; a pod named ",(0,o.kt)("inlineCode",{parentName:"p"},"my-pod")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Running")," state, with ",(0,o.kt)("inlineCode",{parentName:"p"},"1/1")," containers ready:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"NAME     READY   STATUS    RESTARTS   AGE\nmy-pod   1/1     Running   0          38s\n")),(0,o.kt)("h3",{id:"port-forward"},"Port Forward"),(0,o.kt)("p",null,"To view our application, can forward a port on our localhost to the port ",(0,o.kt)("inlineCode",{parentName:"p"},"8501")," on the running pod. W can use local port ",(0,o.kt)("inlineCode",{parentName:"p"},"8888")," with the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl port-forward pod/my-pod 8888:8501\n")),(0,o.kt)("p",null,"To test this is working correctly, we can use the link ",(0,o.kt)("a",{parentName:"p",href:"http://localhost:8888"},"http://localhost:8888")," to see the application running."),(0,o.kt)("h3",{id:"cleanup"},"Cleanup"),(0,o.kt)("p",null,"Before we continue, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Ctrl+C")," to stop the running ",(0,o.kt)("inlineCode",{parentName:"p"},"port-forward")," command, and use the command below to delete the pod resource from the cluster:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete -f pod.yaml\n")),(0,o.kt)("p",null,"Which should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'pod "my-pod" deleted\n')),(0,o.kt)("h2",{id:"more-robust-version"},"More Robust Version"),(0,o.kt)("p",null,"Typically, you're not dealing with ",(0,o.kt)("inlineCode",{parentName:"p"},"pods"),", but rather the ",(0,o.kt)("inlineCode",{parentName:"p"},"deployments")," which manage the replication of pods; their auto-healing if a pod fails; and new app version rollouts and rollback etc."),(0,o.kt)("p",null,"And although port-forwarding in general isn't used in production and we will use it again just to test for this example, the previous example is even less representative of a prod environment as your traffic wouldn't go directly to a pod, it would go through a ",(0,o.kt)("inlineCode",{parentName:"p"},"service")," which load balances across the available replicas of the app."),(0,o.kt)("p",null,"On top of this, since we didn't specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace")," when creating the pod, the app was created in the ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," namespace which is also not common in production."),(0,o.kt)("p",null,"So let's improve on those."),(0,o.kt)("h3",{id:"namespace"},"Namespace"),(0,o.kt)("p",null,"First, lets create a namespace for this app's objects to be created in, which we'll call ",(0,o.kt)("inlineCode",{parentName:"p"},"prod-app"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="namespace.yaml"',title:'"namespace.yaml"'},"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: prod-app\n")),(0,o.kt)("p",null,"Create the namespace using the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f namespace.yaml\n")),(0,o.kt)("p",null,"You should see the below printed to console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"namespace/prod-app created\n")),(0,o.kt)("h3",{id:"deployment"},"Deployment"),(0,o.kt)("p",null,"Next, let's create a deployment of the app, with 3 replicas (with ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.replicas: 3"),"). The ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.template")," is the same as the pod ",(0,o.kt)("a",{parentName:"p",href:"#pod"},"above"),", apart from the added ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.template.metadata.labels")," where we labelled each pod with ",(0,o.kt)("inlineCode",{parentName:"p"},"app = my-app"),". ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/"},(0,o.kt)("inlineCode",{parentName:"a"},"Labels"))," are a very important topic in Kubernetes. They are key/value pairs that are attached to objects such as pods, and are used to identify objects that are relevant to users or other objects."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"spec.selector.matchLabels")," tells the deployment object to manage any pods with the label ",(0,o.kt)("inlineCode",{parentName:"p"},"app = my-app"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.template.metadata.labels")," applies the label to the pods that it will create (3 replica pods in this case). These have to match."),(0,o.kt)("p",null,"Also, note than in ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata.namespace")," we have specified to create the deployment object in the ",(0,o.kt)("inlineCode",{parentName:"p"},"prod-app")," namespace that we previously created."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="deployment.yaml"',title:'"deployment.yaml"'},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\n  namespace: prod-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n        - name: my-container\n          image: justingodden/mystreamlitapp:0.1.0\n          ports:\n            - containerPort: 8501\n")),(0,o.kt)("p",null,"Create the deployment using the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f deployment.yaml\n")),(0,o.kt)("p",null,"You should see the below printed to console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"deployment.apps/my-deployment created\n")),(0,o.kt)("h3",{id:"service"},"Service"),(0,o.kt)("p",null,"Let's now add a ",(0,o.kt)("inlineCode",{parentName:"p"},"Service")," of type ",(0,o.kt)("inlineCode",{parentName:"p"},"ClusterIP")," (accessible inside the cluster) to load balance requests to our pods. Just like the deployment above, services use ",(0,o.kt)("inlineCode",{parentName:"p"},"labels")," to select which pod to route request traffic to. This is found in ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.selector")," with the value ",(0,o.kt)("inlineCode",{parentName:"p"},"app: my-app"),". ",(0,o.kt)("strong",{parentName:"p"},"This must be the same as ",(0,o.kt)("inlineCode",{parentName:"strong"},"spec.template.metadata.labels")," in the deployment above"),"."),(0,o.kt)("p",null,"We've chosen to expose port ",(0,o.kt)("inlineCode",{parentName:"p"},"8080")," on the service, and have traffic directed to port ",(0,o.kt)("inlineCode",{parentName:"p"},"8501")," on all the pods with label ",(0,o.kt)("inlineCode",{parentName:"p"},"app = my-app"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="service.yaml"',title:'"service.yaml"'},"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\n  namespace: prod-app\nspec:\n  selector:\n    app: my-app\n  type: ClusterIP\n  ports:\n    - protocol: TCP\n      port: 8080\n      targetPort: 8501\n")),(0,o.kt)("p",null,"Create the service using the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f service.yaml\n")),(0,o.kt)("p",null,"You should see the below printed to console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"service/my-service created\n")),(0,o.kt)("h3",{id:"ingress"},"Ingress"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Ingress")," objects are a relatively large topic to ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"},"explore"),". Simply put, they expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Kubernetes doesn't by default have the ability to handle ingress definitions. Instead, we use a third-party ",(0,o.kt)("inlineCode",{parentName:"p"},"ingress controller")," to manage our path-based routing ingress rules. There are a few options, but the most popular and the one we'll use is Nginx Ingress Controller."),(0,o.kt)("p",null,"Nginx provide easy ways to install all the components necessary. We can use the specific manifest below which is specifically set up for use with a local ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," cluster:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\n")),(0,o.kt)("p",null,"We can wait until the controller is ready with the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl wait --namespace ingress-nginx \\\n  --for=condition=ready pod \\\n  --selector=app.kubernetes.io/component=controller \\\n  --timeout=90s\n")),(0,o.kt)("p",null,"Now we're ready to create an ",(0,o.kt)("inlineCode",{parentName:"p"},"Ingress")," object. As mentioned, ingresses are worth reading up ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"},"more on"),". But for now to highlight the important parts: they can have many routing rules in ",(0,o.kt)("inlineCode",{parentName:"p"},"spec.rules"),". Here we just make one. We specify an ",(0,o.kt)("inlineCode",{parentName:"p"},"http")," rule, with one ",(0,o.kt)("inlineCode",{parentName:"p"},"path"),". We're using the regex ",(0,o.kt)("inlineCode",{parentName:"p"},"(.*)")," to match any string. The rule says that if the url path ",(0,o.kt)("inlineCode",{parentName:"p"},"/my-app")," plus anything else afterwards (e.g. /my-app/anything/else/etc) then route that to ",(0,o.kt)("inlineCode",{parentName:"p"},"backend.service")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," = ",(0,o.kt)("inlineCode",{parentName:"p"},"my-service")," (the one we created ",(0,o.kt)("a",{parentName:"p",href:"#service"},"above"),") on port ",(0,o.kt)("inlineCode",{parentName:"p"},"8080"),"."),(0,o.kt)("p",null,"Now the problem is, if we go to ",(0,o.kt)("inlineCode",{parentName:"p"},"http://localhost/my-app"),", this would redirect the request to the service as ",(0,o.kt)("inlineCode",{parentName:"p"},"http://my-service:8080/my-app"),". But our app does not have anything set up for path ",(0,o.kt)("inlineCode",{parentName:"p"},"/my-app/"),". It is expecting traffic on the root ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," path. So we use Nginx's ",(0,o.kt)("inlineCode",{parentName:"p"},"rewrite-target")," functionality with the annotation ",(0,o.kt)("inlineCode",{parentName:"p"},"nginx.ingress.kubernetes.io/rewrite-target: /$1"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"$1")," refers to the regex match position, where everything after ",(0,o.kt)("inlineCode",{parentName:"p"},"/my-app/")," goes to the ",(0,o.kt)("inlineCode",{parentName:"p"},"$1")," variable and the url is rewritten to just that. So ",(0,o.kt)("inlineCode",{parentName:"p"},"/my-app/")," would become ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"/my-app/other")," would become ",(0,o.kt)("inlineCode",{parentName:"p"},"/other")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="ingress.yaml"',title:'"ingress.yaml"'},"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\n  namespace: prod-app\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\nspec:\n  rules:\n    - http:\n        paths:\n          - path: /my-app/(.*)\n            pathType: Prefix\n            backend:\n              service:\n                name: my-service\n                port:\n                  number: 8080\n")),(0,o.kt)("p",null,"Create the ingress using the command below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f ingress.yaml\n")),(0,o.kt)("p",null,"You should see the below printed to console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ingress.networking.k8s.io/my-ingress created\n")),(0,o.kt)("p",null,"Finally, to see if our work paid off, we can navigate to ",(0,o.kt)("a",{parentName:"p",href:"http://localhost/my-app/"},"http://localhost/my-app/")," and we should see our application running."),(0,o.kt)("h2",{id:"cleanup-1"},"Cleanup"),(0,o.kt)("p",null,"To delete the objects we created:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete -f ingress.yaml\nkubectl delete -f service.yaml\nkubectl delete -f deployment.yaml\nkubectl delete -f namespace.yaml\n")),(0,o.kt)("h3",{id:"kind-delete-cluster"},(0,o.kt)("inlineCode",{parentName:"h3"},"kind delete cluster")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"We would not recommend deleting the cluster now, as we will be using it in the next section (and indeed the rest of the course - unless using a cloud k8s service). But just for your information of how to delete the cluster.")),(0,o.kt)("p",null,"To delete the cluster, we can use the command ",(0,o.kt)("inlineCode",{parentName:"p"},"kind delete cluster"),"."))}u.isMDXComponent=!0}}]);