"use strict";(self.webpackChunkmlops_made_easy=self.webpackChunkmlops_made_easy||[]).push([[7533],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>c});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),h=p(a),d=l,c=h["".concat(s,".").concat(d)]||h[d]||u[d]||i;return a?n.createElement(c,o(o({ref:t},m),{},{components:a})):n.createElement(c,o({ref:t},m))}));function c(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,o=new Array(i);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[h]="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4672:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var n=a(7462),l=(a(7294),a(3905));const i={sidebar_position:4},o="Helm",r={unversionedId:"kubernetes/helm",id:"kubernetes/helm",title:"Helm",description:"As we see from the previous section, even for a very basic application, we begin to need many manifest files. For a large enterprise application this can grow enormously in which it becomes cumbersome to kubectl create (or delete) so many files. Similarly, we may need to create many of the same application but with different configurations. This is where Helm comes in.",source:"@site/docs/02-kubernetes/04-helm.md",sourceDirName:"02-kubernetes",slug:"/kubernetes/helm",permalink:"/kubernetes/helm",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Up and Running",permalink:"/kubernetes/up-and-running"},next:{title:"\ud83d\udcb0 Cloud Computing",permalink:"/category/-cloud-computing"}},s={},p=[{value:"What is Helm",id:"what-is-helm",level:2},{value:"Installation",id:"installation",level:2},{value:"<code>helm repo</code>",id:"helm-repo",level:2},{value:"<code>helm install</code>",id:"helm-install",level:2},{value:"Values File",id:"values-file",level:2},{value:"<code>helm uninstall</code>",id:"helm-uninstall",level:2},{value:"Creating our own chart",id:"creating-our-own-chart",level:2},{value:"<code>helm create</code>",id:"helm-create",level:3},{value:"Tidy up the folder",id:"tidy-up-the-folder",level:3},{value:"Templating and Built-in objects",id:"templating-and-built-in-objects",level:3},{value:"Functions",id:"functions",level:4},{value:"Control flow",id:"control-flow",level:4},{value:"Built-in objects",id:"built-in-objects",level:4},{value:"Deployment",id:"deployment",level:3},{value:"Service",id:"service",level:3},{value:"Ingress",id:"ingress",level:3},{value:"Default values",id:"default-values",level:3},{value:"Install the chart",id:"install-the-chart",level:3},{value:"Update the chart",id:"update-the-chart",level:3},{value:"Change the default values file",id:"change-the-default-values-file",level:4},{value:"Use our own (non-default) values file",id:"use-our-own-non-default-values-file",level:4},{value:"Use <code>--set</code> flag",id:"use---set-flag",level:4},{value:"Clean up",id:"clean-up",level:3}],m={toc:p},h="wrapper";function u(e){let{components:t,...i}=e;return(0,l.kt)(h,(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"helm"},"Helm"),(0,l.kt)("p",null,"As we see from the previous section, even for a very basic application, we begin to need many manifest files. For a large enterprise application this can grow enormously in which it becomes cumbersome to ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl create")," (or ",(0,l.kt)("inlineCode",{parentName:"p"},"delete"),") so many files. Similarly, we may need to create many of the same application but with different configurations. This is where ",(0,l.kt)("inlineCode",{parentName:"p"},"Helm")," comes in."),(0,l.kt)("h2",{id:"what-is-helm"},"What is Helm"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Helm")," is a package manager for Kubernetes applications. You can group together multiple Kubernetes manifests into one folder, and have a single ",(0,l.kt)("inlineCode",{parentName:"p"},"Helm")," definition file describe the ",(0,l.kt)("inlineCode",{parentName:"p"},"chart")," (packages in Helm are called ",(0,l.kt)("inlineCode",{parentName:"p"},"charts"),"). Also, Helm uses ",(0,l.kt)("a",{parentName:"p",href:"https://pkg.go.dev/text/template"},"Go's templating engine")," to make the underlying Kubernetes manifests more dynamic where you can use variables."),(0,l.kt)("p",null,"This can also be handy to separate chart maintainer from chart user. E.g. The chart maintainer can package up a bunch of k8s manifests that make up an application as a helm chart and only expose a few key parameters as variables. So the user won't have to dig through the manifests to change things, instead can just change the exposed parameter. This will make sense shortly when we create our own chart."),(0,l.kt)("h2",{id:"installation"},"Installation"),(0,l.kt)("p",null,"First let's install Helm. It's best to follow their guide for your particular operating system: ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/intro/install/"},"here"),"."),(0,l.kt)("p",null,"We can test if the installation worked by checking the Helm version that was (hopefully) installed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm version\n")),(0,l.kt)("h2",{id:"helm-repo"},(0,l.kt)("inlineCode",{parentName:"h2"},"helm repo")),(0,l.kt)("p",null,"Helm uses the concept of a ",(0,l.kt)("inlineCode",{parentName:"p"},"repository")," as somewhere which charts are stored. A very popular chart repository is managed by ",(0,l.kt)("a",{parentName:"p",href:"https://bitnami.com/"},"Bitnami"),". We can add their repository address to Helm using the command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm repo add bitnami https://charts.bitnami.com/bitnami\n")),(0,l.kt)("p",null,"We now have access to a ton of pre-build charts of popular open-source applications packaged up as Helm charts, ready to be installed in our Kubernetes cluster. All of their charts can be seen ",(0,l.kt)("a",{parentName:"p",href:"https://artifacthub.io/packages/search?org=bitnami&sort=relevance&page=1"},"here"),"."),(0,l.kt)("h2",{id:"helm-install"},(0,l.kt)("inlineCode",{parentName:"h2"},"helm install")),(0,l.kt)("p",null,"The command ",(0,l.kt)("inlineCode",{parentName:"p"},"helm install")," will, as the name suggests, install an application into our cluster from a specified Helm chart. We'll stick with our basic Nginx example. Luckily, Bitnami manages an Nginx chart ready to install. The command below tells ",(0,l.kt)("inlineCode",{parentName:"p"},"helm")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"install")," a chart, name it ",(0,l.kt)("inlineCode",{parentName:"p"},"my-nginx")," and get it from the ",(0,l.kt)("inlineCode",{parentName:"p"},"bitnami")," repo, and from that repo, use the chart named ",(0,l.kt)("inlineCode",{parentName:"p"},"nginx"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm install my-nginx bitnami/nginx -n nginx --create-namespace\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We're also using the flag ",(0,l.kt)("inlineCode",{parentName:"p"},"-n")," (short for namespace, ",(0,l.kt)("inlineCode",{parentName:"p"},"--namespace")," would also work) to tell Helm to install it in the ",(0,l.kt)("inlineCode",{parentName:"p"},"nginx")," namespace. Now, this would error because we haven't created a namespace called ",(0,l.kt)("inlineCode",{parentName:"p"},"nginx"),", so we also use the flag ",(0,l.kt)("inlineCode",{parentName:"p"},"--create-namespace")," to tell Helm that if the namespace we specified doesn't exist then to create it first.")),(0,l.kt)("p",null,"We can list all charts that have been installed in the ",(0,l.kt)("inlineCode",{parentName:"p"},"nginx")," namespace with the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm list -n nginx\n")),(0,l.kt)("p",null,"Hopefully we should see something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSION\nmy-nginx        nginx           1               2023-05-11 21:19:31.764271744 +0100 BST deployed        nginx-14.0.0    1.24.0\n")),(0,l.kt)("p",null,"We can also use ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl")," to see all the objects created using the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get all -n nginx\n")),(0,l.kt)("p",null,"Giving something like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"NAME                            READY   STATUS    RESTARTS   AGE\npod/my-nginx-74b4885cbf-86dvt   1/1     Running   0          13s\n\nNAME               TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\nservice/my-nginx   LoadBalancer   10.96.79.211   <pending>     80:30874/TCP   13s\n\nNAME                       READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/my-nginx   1/1     1            1           13s\n\nNAME                                  DESIRED   CURRENT   READY   AGE\nreplicaset.apps/my-nginx-74b4885cbf   1         1         1       13s\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We can see the chart created a service of type ",(0,l.kt)("inlineCode",{parentName:"p"},"LoadBalancer"),". But what if we would prefer type ",(0,l.kt)("inlineCode",{parentName:"p"},"ClusterIP")," instead?")),(0,l.kt)("h2",{id:"values-file"},"Values File"),(0,l.kt)("p",null,"Helm uses a ",(0,l.kt)("inlineCode",{parentName:"p"},"values file")," which overwrites the 'templated' values in the manifests (we'll see this in greater detail ",(0,l.kt)("a",{parentName:"p",href:"#helm-create"},"when we create out own Helm chart"),"). Each chart comes with default values used for these templated variables, and if you don't do anything, they will be used. We can see the default values ",(0,l.kt)("a",{parentName:"p",href:"https://artifacthub.io/packages/helm/bitnami/nginx?modal=values&path=service"},"here"),". There are ",(0,l.kt)("strong",{parentName:"p"},"a lot")," of lines in that link. These types of publicly available charts are very comprehensive to be maximally flexible for users. Though, the above link should take you to the exact section we're interested in. We can see that the default value for ",(0,l.kt)("inlineCode",{parentName:"p"},"service.type")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"LoadBalancer"),"."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"values",src:a(7307).Z,width:"715",height:"327"})),(0,l.kt)("p",null,"Now the beauty of Helm is that we can chose to overwrite only what we want. So we can create a file called ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," and just add the two lines below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="values.yaml"',title:'"values.yaml"'},"service:\n  type: ClusterIP\n")),(0,l.kt)("p",null,"And when using this with Helm, it will overwrite those specifically, and use the default values for everything else."),(0,l.kt)("p",null,"We can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"helm upgrade")," command to upgrade an already installed application using the form ",(0,l.kt)("inlineCode",{parentName:"p"},"helm upgrade <release-name> <repo-name>/<chart-name> --values <path-to-values-file>"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm upgrade my-nginx bitnami/nginx --values values.yaml -n nginx\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We could have used the following command if we hadn't already installed this chart with name ",(0,l.kt)("inlineCode",{parentName:"p"},"my-nginx"),":"),(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"helm install my-nginx bitnami/nginx --values values.yaml -n nginx --create-namespace")),(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"install")," is used for creating a new application. ",(0,l.kt)("inlineCode",{parentName:"p"},"upgrade")," is for updating an already installed application.")),(0,l.kt)("p",null,"Now if we use the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get service -n nginx\n")),(0,l.kt)("p",null,"We should hopefully get something like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE\nmy-nginx   ClusterIP   10.96.79.211   <none>        80/TCP    38m\n")),(0,l.kt)("p",null,"Great, our service has been updated to be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"ClusterIP"),", and this was done with a Helm values file; we didn't have to dig through the underlying kubernetes object definition manifest files that make up the application."),(0,l.kt)("h2",{id:"helm-uninstall"},(0,l.kt)("inlineCode",{parentName:"h2"},"helm uninstall")),(0,l.kt)("p",null,"Before we learn how to create our own Helm chart we can clean up our previous installation with the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm uninstall my-nginx -n nginx\n")),(0,l.kt)("h2",{id:"creating-our-own-chart"},"Creating our own chart"),(0,l.kt)("p",null,"Now let's have a look at how we can create our own Helm chart of the same application we made in the ",(0,l.kt)("a",{parentName:"p",href:"up-and-running#more-robust-version"},"previous")," tutorial."),(0,l.kt)("h3",{id:"helm-create"},(0,l.kt)("inlineCode",{parentName:"h3"},"helm create")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"helm create")," command is a handy way to create a chart directory along with the common files and directories used in a chart. We can name the new chart ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm create my-app\n")),(0,l.kt)("p",null,"This should create a folder and files as below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},".\n\u2514\u2500\u2500 my-app\n    \u251c\u2500\u2500 .helmignore\n    \u251c\u2500\u2500 charts\n    \u251c\u2500\u2500 Chart.yaml\n    \u251c\u2500\u2500 templates\n    \u2502   \u251c\u2500\u2500 deployment.yaml\n    \u2502   \u251c\u2500\u2500 _helpers.tpl\n    \u2502   \u251c\u2500\u2500 hpa.yaml\n    \u2502   \u251c\u2500\u2500 ingress.yaml\n    \u2502   \u251c\u2500\u2500 NOTES.txt\n    \u2502   \u251c\u2500\u2500 serviceaccount.yaml\n    \u2502   \u251c\u2500\u2500 service.yaml\n    \u2502   \u2514\u2500\u2500 tests\n    \u2502       \u2514\u2500\u2500 test-connection.yaml\n    \u2514\u2500\u2500 values.yaml\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},".helmignore"),": Tells Helm which files and folders to ignore when packaging a chart."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"charts/"),": This contains and sub-chart dependencies. We won't worry about this now."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Chart.yaml"),": This is the main definition file for Helm charts. Contains chart name, version number etc."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"templates/"),": Contains all the Kubernetes manifests that make up the chart."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"templates/tests/"),": Contains tests"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"values.yaml"),": The default values for the manifest templates.")),(0,l.kt)("h3",{id:"tidy-up-the-folder"},"Tidy up the folder"),(0,l.kt)("p",null,"We won't need all the files, so let's clean up the folder a bit. We won't need the ",(0,l.kt)("inlineCode",{parentName:"p"},"charts/")," folder, but it's empty anyway, so we can leave it as it is. Delete everything in the ",(0,l.kt)("inlineCode",{parentName:"p"},"templates/")," folder so we have a clean slate to put our own k8s manifests in. Delete the ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file so we can make our own one (alternatively you can just delete everything inside the file)."),(0,l.kt)("p",null,"The folder structure should look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},".\n\u2514\u2500\u2500 my-app\n    \u251c\u2500\u2500 .helmignore\n    \u251c\u2500\u2500 charts\n    \u251c\u2500\u2500 Chart.yaml\n    \u2514\u2500\u2500 templates\n")),(0,l.kt)("p",null,"Okay, now let's add our files. To match the application from the previous tutorial, we will need a ",(0,l.kt)("inlineCode",{parentName:"p"},"deployment.yaml"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"service.yaml")," and an ",(0,l.kt)("inlineCode",{parentName:"p"},"ingress.yaml"),". Put those in the ",(0,l.kt)("inlineCode",{parentName:"p"},"templates/")," folder. Also create a ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file and put it in the chart's root directory."),(0,l.kt)("p",null,"The folder structure should now look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},".\n\u2514\u2500\u2500 my-app\n    \u251c\u2500\u2500 .helmignore\n    \u251c\u2500\u2500 charts\n    \u251c\u2500\u2500 Chart.yaml\n    \u251c\u2500\u2500 templates\n    \u2502   \u251c\u2500\u2500 deployment.yaml\n    \u2502   \u251c\u2500\u2500 service.yaml\n    \u2502   \u2514\u2500\u2500 ingress.yaml\n    \u2514\u2500\u2500 values.yaml\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We didn't make a ",(0,l.kt)("inlineCode",{parentName:"p"},"namespace.yaml")," file as we can just tell Helm which namespace to install our application into.")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We didn't change the ",(0,l.kt)("inlineCode",{parentName:"p"},"Chart.yaml")," file as ",(0,l.kt)("inlineCode",{parentName:"p"},"helm create")," gives us sensible defaults. If you want to change this you can read up on it ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/topics/charts/#the-chartyaml-file"},"more"),".")),(0,l.kt)("h3",{id:"templating-and-built-in-objects"},"Templating and Built-in objects"),(0,l.kt)("p",null,"Helm uses Go's ",(0,l.kt)("a",{parentName:"p",href:"https://pkg.go.dev/text/template"},"templating engine")," to add custom logic, functions and variables into the YAML template files."),(0,l.kt)("p",null,"There's plenty to read up on how Helm uses templating, and we recommend you ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/chart_template_guide/"},"do so"),". But the basic syntax is to put code between double curly braces: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ }}"),"."),(0,l.kt)("h4",{id:"functions"},"Functions"),(0,l.kt)("p",null,"There are built-in ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/chart_template_guide/function_list/"},"functions"),", such as ",(0,l.kt)("inlineCode",{parentName:"p"},"and"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"or"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," etc. We won't use any of these just yet but are useful to learn."),(0,l.kt)("h4",{id:"control-flow"},"Control flow"),(0,l.kt)("p",null,"There is ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/chart_template_guide/control_structures/"},"control flow"),", such as ",(0,l.kt)("inlineCode",{parentName:"p"},"if"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"else")," for creating conditional blocks. This looks like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{{ if <boolean-expression> }}\nsome yaml\n{{ end }}\n")),(0,l.kt)("h4",{id:"built-in-objects"},"Built-in objects"),(0,l.kt)("p",null,"And most importantly, there are built-in ",(0,l.kt)("a",{parentName:"p",href:"https://helm.sh/docs/chart_template_guide/builtin_objects/"},"objects")," which can be accessed from within a template. The most common one is the ",(0,l.kt)("inlineCode",{parentName:"p"},"Values")," object, which contains values from the ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file. This is what gives Helm such flexibility. To access these values, we use the double curly brace syntax ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ .Values.some.default.value }}")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Release")," object is also useful, and contains information about the release. A release is what Helm calls an installation of a chart. So you can you access ",(0,l.kt)("inlineCode",{parentName:"p"},"Release.Name")," for example which contains what you named the install. For example, using command ",(0,l.kt)("inlineCode",{parentName:"p"},"helm install my-app bitnami/nginx"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Release.Name")," would be ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app"),"."),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Note the ",(0,l.kt)("inlineCode",{parentName:"p"},".")," at the beginning when using ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ .Values }}")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ .Release }}"),". This can be a little confusing, but essentially Helm creates a top-level root object that contains all the other built-in objects. So we first access the top level object with a ",(0,l.kt)("inlineCode",{parentName:"p"},".")," and the use the variable names inside it.")),(0,l.kt)("p",null,"Let's fill in the templates."),(0,l.kt)("h3",{id:"deployment"},"Deployment"),(0,l.kt)("p",null,"This deployment is exactly the same as the previous ",(0,l.kt)("a",{parentName:"p",href:"up-and-running#deployment"},"tutorial"),", except the highlighted parts with new templated variables."),(0,l.kt)("p",null,"First we use the release name to name the deployment. So if we use ",(0,l.kt)("inlineCode",{parentName:"p"},"helm install my-app <chart-name>"),", then the deployment name would be ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app-deployment"),"."),(0,l.kt)("p",null,"Next, we'll use the ",(0,l.kt)("inlineCode",{parentName:"p"},"Values")," object to access how many replicas, the image name and the image tag. We'll see how this looks in the ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file ",(0,l.kt)("a",{parentName:"p",href:"#default-values"},"below"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="my-app/templates/deployment.yaml"',title:'"my-app/templates/deployment.yaml"'},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  # highlight-next-line\n  name: {{ .Release.Name }}-deployment\nspec:\n  # highlight-next-line\n  replicas: {{ .Values.replicas }} # prettier ignore\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n        - name: my-container\n          # highlight-next-line\n          image: "{{ .Values.image.name }}:{{ .Values.image.tag }}"\n          ports:\n            - containerPort: 8501\n')),(0,l.kt)("h3",{id:"service"},"Service"),(0,l.kt)("p",null,"Very similar to the deployment above, the service will get its name from the Helm release name, and we've also decided to make what type of service to use to be variable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="my-app/templates/service.yaml"',title:'"my-app/templates/service.yaml"'},'apiVersion: v1\nkind: Service\nmetadata:\n  # highlight-next-line\n  name: {{ .Release.Name }}-service\nspec:\n  selector:\n    app: my-app\n  # highlight-next-line\n  type: "{{ .Values.service.type }}"\n  ports:\n    - protocol: TCP\n      port: 8080\n      targetPort: 8501\n')),(0,l.kt)("h3",{id:"ingress"},"Ingress"),(0,l.kt)("p",null,"Also similar to deployment and service above, the ingress will get its name from the release, and the URL path to use can also be decided by the chart user in the values file."),(0,l.kt)("p",null,"We've also encapsulated the entire template in an ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," statement, which checks the boolean expressions it's given to determine whether to include the enclosed yaml code. We will ",(0,l.kt)("a",{parentName:"p",href:"#default-values"},"see")," ",(0,l.kt)("inlineCode",{parentName:"p"},"Values.ingress.enabled")," is a boolean value (default ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),"), so this is a nice way to make adding Kubernetes objects optional."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="my-app/templates/ingress.yaml"',title:'"my-app/templates/ingress.yaml"'},"# highlight-next-line\n{{ if .Values.ingress.enabled }}\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  # highlight-next-line\n  name: {{ .Release.Name }}-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\nspec:\n  rules:\n    - http:\n        paths:\n          # highlight-next-line\n          - path: /{{ .Values.ingress.urlPath }}/(.*)\n            pathType: Prefix\n            backend:\n              service:\n                name: {{ .Release.Name }}-service\n                port:\n                  number: 8080\n# highlight-next-line\n{{ end }}\n")),(0,l.kt)("h3",{id:"default-values"},"Default values"),(0,l.kt)("p",null,"Finally, let's create the default values file that will populate the ",(0,l.kt)("inlineCode",{parentName:"p"},"Values")," object for use in the templates:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="my-app/values.yaml"',title:'"my-app/values.yaml"'},"replicas: 3\n\nimage:\n  name: justingodden/mystreamlitapp\n  tag: 0.1.0\n\nservice:\n  type: ClusterIP\n\ningress:\n  enabled: true\n  urlPath: my-app\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Remember that the ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file goes into the root directory of the chart, not in the ",(0,l.kt)("inlineCode",{parentName:"p"},"templates")," folder.")),(0,l.kt)("h3",{id:"install-the-chart"},"Install the chart"),(0,l.kt)("p",null,"Let's install our chart. Assume you followed the instructions above and used ",(0,l.kt)("inlineCode",{parentName:"p"},"helm create my-app"),", you current working directory contains the folder ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app"),". If you are inside the ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app")," folder, use ",(0,l.kt)("inlineCode",{parentName:"p"},"cd ..")," to move up one level. This will be useful shortly."),(0,l.kt)("p",null,"Remember the install command is ",(0,l.kt)("inlineCode",{parentName:"p"},"helm install <release-name> <chart-location> [COMMANDS]"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"<chart-location>")," can be a repo URL that is hosted online. For us, this is just the ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app")," folder path."),(0,l.kt)("p",null,"So we can give the release a name of ",(0,l.kt)("inlineCode",{parentName:"p"},"my-release")," and use the command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm install my-release my-app\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"If our current working directory was inside the ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app")," chart folder, then the command would be ",(0,l.kt)("inlineCode",{parentName:"p"},"helm install my-release ."),".")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Note we didn't include and namespace information, so the app is installed into the ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," namespace.")),(0,l.kt)("p",null,"If all done correctly, we should be able to see the app by going to ",(0,l.kt)("a",{parentName:"p",href:"http://localhost/my-app/"},"http://localhost/my-app/"),"."),(0,l.kt)("h3",{id:"update-the-chart"},"Update the chart"),(0,l.kt)("p",null,"Great, now let's see how easy it is to update the variables that we added to the templates."),(0,l.kt)("p",null,"There are 3 main ways do this this:"),(0,l.kt)("h4",{id:"change-the-default-values-file"},"Change the default values file"),(0,l.kt)("p",null,"We can simply change the values in the ",(0,l.kt)("inlineCode",{parentName:"p"},"values.yaml")," file in the chart and use ",(0,l.kt)("inlineCode",{parentName:"p"},"helm upgrade my-release my-app")," to see it take effect."),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"This is not recommended unless you truly want to update the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("em",{parentName:"strong"},"default"))," values. Default values are there for a reason as sensible defaults put there by the chart developer. It's for the chart user to add their own values on top of the default ones (like we did in the ",(0,l.kt)("a",{parentName:"p",href:"#values-file"},"previous example"),")"),(0,l.kt)("p",{parentName:"admonition"},"You can think of this like a Python function. We have a sensible default (",(0,l.kt)("inlineCode",{parentName:"p"},"param = True"),") in the function definition, but can be overridden when calling the function. But we wouldn't change the function definition unless we thought those were more sensible permanent defaults:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def func(param: bool = True) -> None:\n  pass\n\nfunc(param=False)\n"))),(0,l.kt)("h4",{id:"use-our-own-non-default-values-file"},"Use our own (non-default) values file"),(0,l.kt)("p",null,"A better way is to use another ",(0,l.kt)("inlineCode",{parentName:"p"},"values")," file to override the default values. Even though we have the chart in our working directory, you can imagine the chart being in an online repo, which has its default values, and we use our own file to override some values like we did in the Bitnami Nginx example."),(0,l.kt)("p",null,"Maybe we want to change what the URL path that we use to access the app. So we can create a file and call it ",(0,l.kt)("inlineCode",{parentName:"p"},"my-values.yaml")," and override ",(0,l.kt)("inlineCode",{parentName:"p"},"ingress.urlPath")," to use the value ",(0,l.kt)("inlineCode",{parentName:"p"},"streamlit")," instead:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="my-values.yaml"',title:'"my-values.yaml"'},"ingress:\n  urlPath: streamlit\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"The folder structure should look like:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre"},".\n\u251c\u2500\u2500 my-values.yaml\n\u2514\u2500\u2500 my-app\n    \u251c\u2500\u2500 templates\n    ...\n    \u2514\u2500\u2500 values.yaml\n\n"))),(0,l.kt)("p",null,"Now we can use the command below to update the release to use our values on top of the default ones:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm upgrade my-release my-app --values my-values.yaml\n")),(0,l.kt)("p",null,"Now, the previous URL should return a ",(0,l.kt)("inlineCode",{parentName:"p"},"404 Not Found")," error, and the app should be be found at ",(0,l.kt)("a",{parentName:"p",href:"http://localhost/streamlit/"},"http://localhost/streamlit/"),"."),(0,l.kt)("h4",{id:"use---set-flag"},"Use ",(0,l.kt)("inlineCode",{parentName:"h4"},"--set")," flag"),(0,l.kt)("p",null,"The final way we can override the default default values is using the ",(0,l.kt)("inlineCode",{parentName:"p"},"--set")," flag. This also isn't recommended as there's no ",(0,l.kt)("em",{parentName:"p"},"audit trail")," of what went into a release. I.e. no values file to see what definition the release was made from."),(0,l.kt)("p",null,"Nonetheless, we can show it in action here by updating the number of replicas:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm upgrade my-release my-app --reuse-values --set replicas=2\n")),(0,l.kt)("p",null,"We can check it work with:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get deployments\n")),(0,l.kt)("p",null,"Which should show that the deployment now has ",(0,l.kt)("inlineCode",{parentName:"p"},"2")," pods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"NAME                    READY   UP-TO-DATE   AVAILABLE   AGE\nmy-release-deployment   2/2     2            2           34m\n")),(0,l.kt)("admonition",{title:"Note",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Note we used the flag ",(0,l.kt)("inlineCode",{parentName:"p"},"--reuse-values"),". This tells Helm to keep all current values and just change the ones that we're now setting."),(0,l.kt)("p",{parentName:"admonition"},"If we were to just use ",(0,l.kt)("inlineCode",{parentName:"p"},"helm upgrade my-release my-app --set replicas=2")," without ",(0,l.kt)("inlineCode",{parentName:"p"},"--reuse-values"),", this would reapply all the default values from the ",(0,l.kt)("inlineCode",{parentName:"p"},"my-app")," chart, and only override what we added with ",(0,l.kt)("inlineCode",{parentName:"p"},"--set")," (I.e. not using our values from ",(0,l.kt)("inlineCode",{parentName:"p"},"my-values.yaml"),")."),(0,l.kt)("p",{parentName:"admonition"},"To do it this way and include our ",(0,l.kt)("inlineCode",{parentName:"p"},"my-values")," again, we'd need to do:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm upgrade my-release my-app --values my-values.yaml --set replicas=2\n")),(0,l.kt)("p",{parentName:"admonition"},"But it's just easier to use ",(0,l.kt)("inlineCode",{parentName:"p"},"--reuse-values"),".")),(0,l.kt)("h3",{id:"clean-up"},"Clean up"),(0,l.kt)("p",null,"We can uninstall the Helm release, thus removing all the Kubernetes objects it created with the command below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"helm uninstall my-release\n")))}u.isMDXComponent=!0},7307:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/values-1b26f4797fb95db9ae95b2b557489b0e.png"}}]);